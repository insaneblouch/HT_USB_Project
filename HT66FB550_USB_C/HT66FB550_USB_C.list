				;file C:\Users\james\Google 雲端硬碟\自製版子\holtek\GitHub\HT_USB_Project\HT66FB550_USB_C\main.c
				;1	#include "HT66FB550.h"
				;2	#include "HT66FB550_MCU.h"
				;3	#include "HT66FB550_IO.h"
				;4	#include "HT66FB550_typedef.h"
				;5	#include "HT66FB550_UART.h"
				;6	
				;7	void main()
				;8	{
				@code .SECTION 'CODE'
				include HT66FB550.inc
0000	2801	jmp     _main_startup1
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0001	2828	jmp     _main
				;9		volatile int a;
				;10		HT66FB550_MCU_Init();
				@dummy36 .SECTION 'CODE'
				_main:
				_main:
0028	2002	call    _HT66FB550_MCU_Init
				;11		HT66FB550_IO_INIT();
0029	2136	call    _HT66FB550_IO_INIT
				;12		//_acer0 = 0;
				;13		//_acer1 = 0;
				;14		//_pbc = 0;
				;15		UART_Init();
002A	200A	call    _UART_Init
				;16		
				;17		_pb1 = 1;
002B	30A2	set     PB1
				;18		loop:
				;19		UART_Put_Char(0x42);
				_L2:
002C	0F42	mov     a, 42H
002D	223B	call    _UART_Put_Char
				;20		UART_Put_Char(0x42);
002E	0F42	mov     a, 42H
002F	223B	call    _UART_Put_Char
				;21		UART_Put_Char(0x42);
0030	0F42	mov     a, 42H
0031	223B	call    _UART_Put_Char
				;22		UART_Put_Char(0x43);
0032	0F43	mov     a, 43H
0033	223B	call    _UART_Put_Char
				;23		UART_Put_Char(0x42);
0034	0F42	mov     a, 42H
0035	223B	call    _UART_Put_Char
				;24		UART_Put_Char(0x41);
0036	0F41	mov     a, 41H
0037	223B	call    _UART_Put_Char
				;25		UART_Put_Char(0x41);
0038	0F41	mov     a, 41H
0039	223B	call    _UART_Put_Char
				;26		UART_Put_Char('\n');
003A	0F0A	mov     a, AH
003B	223B	call    _UART_Put_Char
				;27		UART_Start();
003C	21FC	call    _UART_Start
				;28		for(a=0; a<10000; a++);
003D	5F27	clr     a[0]
003E	5F28	clr     a[1]
				_L3:
003F	0F0F	mov     a, FH
0040	4227	sub     a, a[0]
0041	0F27	mov     a, 27H
0042	5228	sbc     a, a[1]
0043	1185	swap    ACC
0044	040A	xor     a, STATUS
0045	3D85	sz      ACC.3
0046	282C	jmp     _L2
0047	54A7	inc     a[0]
0048	3D0A	sz      Z
0049	54A8	inc     a[1]
004A	283F	jmp     _L3
004B	284B	jmp     $
				;29		goto loop;
				;30	}
				;file C:\Users\james\Google 雲端硬碟\自製版子\holtek\GitHub\HT_USB_Project\HT66FB550_USB_Common\HT66FB550_MCU.c
				;1	#include "HT66FB550.h"
				;2	#include "HT66FB550_typedef.h"
				;3	#include "Config.h"
				;4	
				;5	/*  HT66FB550 INIT
				;6	    step:
				;7	        1.setting PLL(configure by config.h)
				;8	        2.cancel WDT
				;9	    Notification: This function is also cancel USB-related config
				;10	*/
				;11	//#ifndef HT66FB550_MCU_Speed
				;12		//#define HT66FB550_MCU_Speed HT66FB550_16Mhz
				;13	//#endif
				;14	
				;15	#if HT66FB550_MCU_Speed == HT66FB550_6Mhz
				;16	void HT66FB550_MCU_Init(void)
				;17	{
				;18		//1.setting PLL source(6Mhz) -> PLL -> Fh=16Mhz -> Fsys=16Mhz (It seem like little error in here, try later)
				;19	    _ucc    = 0x60;         //sysclk=6MHz,Fsys16MHz=1
				;20	    _usc    = 0x20;         //pll=on
				;21	    _smod   = 0xE1;         //Fsys_clock_divider=none;direct come for Fh
				;22	    //2.cancel WDT
				;23	    _wdtc   = 0xAC;
				;24	}
				;25	#elif HT66FB550_MCU_Speed == HT66FB550_16Mhz
				;26	void HT66FB550_MCU_Init(void)
				;27	{
				;28	    //1.setting PLL source(6Mhz) -> PLL -> Fh=16Mhz -> Fsys=16Mhz (It seem like little error in here, try later)
				;29	    _ucc    = 0x60;         //sysclk=6MHz,Fsys16MHz=1
				_HT66FB550_MCU_Init:
				_HT66FB550_MCU_Init:
0002	0F60	mov     a, 60H
0003	00E8	mov     UCC, a
				;30	    _usc    = 0x00;         //pll=on
0004	1F66	clr     USC
				;31	    _smod   = 0xE1;         //Fsys_clock_divider=none;direct come for Fh
0005	0FE1	mov     a, E1H
0006	008B	mov     SMOD, a
				;32	    //2.cancel WDT
				;33	    _wdtc   = 0xAC;
0007	0FAC	mov     a, ACH
0008	008E	mov     WDTC, a
0009	0003	ret
				;34	}
				;35	
				;36	#endif
				;file C:\Users\james\Google 雲端硬碟\自製版子\holtek\GitHub\HT_USB_Project\HT66FB550_USB_Common\HT66FB550_UART.c
				;1	#ifndef HT66FB550_UART_H
				;2	#define HT66FB550_UART_H
				;3	
				;4	#include "HT66FB550.h"
				;5	#include "HT66FB550_typedef.h"
				;6	#include "HT66FB550_UART.h"
				;7	#include "Config.h"
				;8	
				;9	#define UART_TX_PIN _pb1
				;10	#if HT66FB550_MCU_Speed == HT66FB550_6Mhz
				;11	    #define tm3al_reload  0x04; 
				;12	    #define tm3ah_reload  0x02;
				;13	#elif HT66FB550_MCU_Speed == HT66FB550_16Mhz
				;14	    #define tm3al_reload  0xD8;
				;15	    #define tm3ah_reload  0x02;
				;16	#endif
				;17	
				;18	#define tm3reload()	_tm3al=tm3al_reload;_tm3ah=tm3ah_reload;
				;19	
				;20	char uart_step,uart_out_buf,uart_pin_buf,uart_head,uart_tail;
				;21	volatile static unsigned char uart_buf[100]__attribute__((at(0x480)));
				;22	
				;23	void __attribute((interrupt(0x24)))	ISR_timer3(void)
				;24	{
				@ISR_timer3_code .SECTION 'CODE'
0024	409C	mov     r124, a
0025	0704	mov     a, BP
0026	409D	mov     r224, a
0027	29DD	jmp     _ISR_timer3
				_ISR_timer3:
				_ISR_timer3:
01DD	070A	mov     a, STATUS
01DE	409E	mov     r324, a
01DF	0703	mov     a, MP1
01E0	409F	mov     r424, a
01E1	0701	mov     a, MP0
01E2	40A0	mov     r524, a
01E3	0707	mov     a, TBLP
01E4	40A1	mov     r624, a
01E5	0709	mov     a, TBHP
01E6	40A2	mov     r724, a
				;25		if(_t3af){
01E7	3B95	snz     T3AF
01E8	29ED	jmp     _L18
				;26			_t3af = 0;
01E9	3795	clr     T3AF
				;27			_t3on = 0;
01EA	35DE	clr     T3ON
				;28			_t3on = 1;
01EB	31DE	set     T3ON
				;29			UART_ISR();
01EC	2161	call    _UART_ISR
				_L18:
01ED	471D	mov     a, r224
01EE	0084	mov     BP, a
01EF	471E	mov     a, r324
01F0	008A	mov     STATUS, a
01F1	471F	mov     a, r424
01F2	0083	mov     MP1, a
01F3	4720	mov     a, r524
01F4	0081	mov     MP0, a
01F5	4721	mov     a, r624
01F6	0087	mov     TBLP, a
01F7	4722	mov     a, r724
01F8	0089	mov     TBHP, a
01F9	1D05	tabrd   ACC
01FA	471C	mov     a, r124
01FB	0004	reti
				;30		}		
				;31		return;
				;32	}
				;33	
				;34	void UART_ISR(void)
				;35	{
				;36		UART_TX_PIN = uart_pin_buf;
				_UART_ISR:
				_UART_ISR:
0161	4711	mov     a, uart_pin_buf[0]
0162	0E01	and     a, 1H
0163	4098	mov     ra24, a
0164	4718	mov     a, ra24
0165	4398	addm    a, ra24
0166	0722	mov     a, PB
0167	4099	mov     rb24, a
0168	7499	clr     rb24.1
0169	4719	mov     a, rb24
016A	4518	or      a, ra24
016B	00A2	mov     PB, a
				;37		switch(uart_step)
016C	4713	mov     a, uart_step[0]
016D	0A00	sub     a, 0H
016E	3D0A	sz      Z
016F	299B	jmp     _L3
0170	0A01	sub     a, 1H
0171	3D0A	sz      Z
0172	299D	jmp     _L4
0173	4713	mov     a, uart_step[0]
0174	0A02	sub     a, 2H
0175	3D0A	sz      Z
0176	299D	jmp     _L4
0177	0A01	sub     a, 1H
0178	3D0A	sz      Z
0179	299D	jmp     _L4
017A	4713	mov     a, uart_step[0]
017B	0A04	sub     a, 4H
017C	3D0A	sz      Z
017D	299D	jmp     _L4
017E	0A01	sub     a, 1H
017F	3D0A	sz      Z
0180	299D	jmp     _L4
0181	4713	mov     a, uart_step[0]
0182	0A06	sub     a, 6H
0183	3D0A	sz      Z
0184	299D	jmp     _L4
0185	0A01	sub     a, 1H
0186	3D0A	sz      Z
0187	299D	jmp     _L4
0188	4713	mov     a, uart_step[0]
0189	0A08	sub     a, 8H
018A	3D0A	sz      Z
018B	299D	jmp     _L4
018C	0A01	sub     a, 1H
018D	3D0A	sz      Z
018E	29A7	jmp     _L5
018F	4713	mov     a, uart_step[0]
0190	0A0A	sub     a, AH
0191	3D0A	sz      Z
0192	29A7	jmp     _L5
0193	0A01	sub     a, 1H
0194	3D0A	sz      Z
0195	29A7	jmp     _L5
0196	4713	mov     a, uart_step[0]
0197	0A0C	sub     a, CH
0198	390A	snz     Z
0199	29DB	jmp     _L2
019A	29AA	jmp     _L17
				;38		{
				;39			case 0:
				;40				uart_pin_buf=0;
				_L3:
019B	5F11	clr     uart_pin_buf[0]
				;41				break;	
019C	29DB	jmp     _L2
				;42			case 1:
				;43			case 3:
				;44			case 5:
				;45			case 7:
				;46			case 2:
				;47			case 4:
				;48			case 6:
				;49			case 8:
				;50	            uart_pin_buf = uart_out_buf & 0x01;
				_L4:
019D	4712	mov     a, uart_out_buf[0]
019E	4098	mov     ra24, a
019F	4718	mov     a, ra24
01A0	0E01	and     a, 1H
01A1	4091	mov     uart_pin_buf[0], a
				;51	            uart_out_buf = uart_out_buf >> 1;
01A2	5A18	rlca    ra24
01A3	5B98	rrc     ra24
01A4	4718	mov     a, ra24
01A5	4092	mov     uart_out_buf[0], a
				;52				break;
01A6	29DB	jmp     _L2
				;53			case 9:		//stop bit
				;54			case 10:	//stop bit hold
				;55			case 11:	//stop bit hold
				;56				uart_pin_buf = 1;
				_L5:
01A7	0F01	mov     a, 1H
01A8	4091	mov     uart_pin_buf[0], a
				;57				break;
01A9	29DB	jmp     _L2
				;58			case 12:
				;59	            if((uart_head==uart_tail) & (uart_buf[uart_head]==0)){
				_L17:
01AA	4710	mov     a, uart_head[0]
01AB	409A	mov     rd24, a
01AC	470F	mov     a, uart_tail[0]
01AD	4098	mov     ra24, a
01AE	471A	mov     a, rd24
01AF	4099	mov     rb24, a
01B0	5F1B	clr     rc24
01B1	3F85	sz      ACC.7
01B2	5F9B	set     rc24
01B3	0F80	mov     a, 80H
01B4	4319	add     a, rb24
01B5	0083	mov     MP1, a
01B6	0F04	mov     a, 4H
01B7	531B	adc     a, rc24
01B8	0081	mov     MP0, a
01B9	2019	call    L0019
01BA	4099	mov     rb24, a
01BB	5099	sz      rb24
01BC	29C3	jmp     _L7
01BD	471A	mov     a, rd24
01BE	4218	sub     a, ra24
01BF	390A	snz     Z
01C0	29C3	jmp     _L7
				;60	                UART_Stop();
				;61	                return;
				;62	            }
				;63	            uart_step = -1;
				_L7:
01C3	5F93	set     uart_step[0]
				;64	            uart_pin_buf=1;
01C4	0F01	mov     a, 1H
01C5	4091	mov     uart_pin_buf[0], a
				;65	            uart_out_buf = uart_buf[uart_tail];
01C6	4718	mov     a, ra24
01C7	4099	mov     rb24, a
01C8	5F1B	clr     rc24
01C9	3F85	sz      ACC.7
01CA	5F9B	set     rc24
01CB	0F80	mov     a, 80H
01CC	4319	add     a, rb24
01CD	0083	mov     MP1, a
01CE	0F04	mov     a, 4H
01CF	531B	adc     a, rc24
01D0	0081	mov     MP0, a
01D1	2019	call    L0019
01D2	4092	mov     uart_out_buf[0], a
				;66	            //uart_out_buf = 0x41;
				;67	            uart_buf[uart_tail] = 0;
01D3	0701	mov     a, MP0
01D4	0084	mov     BP, a
01D5	0F00	mov     a, 0H
01D6	0082	mov     [02H], a
				;68	            uart_tail++;
01D7	5498	inc     ra24
				;69	            uart_tail = uart_tail & 0x7f;
01D8	7798	clr     ra24.7
01D9	4718	mov     a, ra24
01DA	408F	mov     uart_tail[0], a
				;70				break;		
				;71		}
				;72		uart_step++;
				_L2:
01DB	5493	inc     uart_step[0]
				_L1:
01DC	0003	ret
				;73		return;
				;74	}
				;75	void UART_Init(void)
				;76	{
				;77	    _tm3c0 = 0x10;
				_UART_Init:
				_UART_Init:
000A	0F10	mov     a, 10H
000B	00DE	mov     TM3C0, a
				;78	    _tm3c1 = 0xC0;
000C	0FC0	mov     a, C0H
000D	00DF	mov     TM3C1, a
				;79	    uart_head = 0;
000E	5F10	clr     uart_head[0]
				;80	    uart_tail = 0;
000F	5F0F	clr     uart_tail[0]
				;81		tm3reload();
0010	0FD8	mov     a, D8H
0011	00E2	mov     TM3AL, a
0012	0F02	mov     a, 2H
0013	00E3	mov     TM3AH, a
				;82	    _mf3e = 1;
0014	3092	set     MF3E
				;83	    _t3ae = 1;
0015	3195	set     T3AE
				;84	    _emi = 1;
0016	3010	set     EMI
0017	0003	ret
0018	1483	inc     MP1
				L0019:
0019	0701	mov     a, MP0
001A	0084	mov     BP, a
001B	0702	mov     a, [02H]
001C	0003	ret
001D	0000	nop
001E	0000	nop
001F	0000	nop
0020	0000	nop
0021	0000	nop
0022	0000	nop
0023	0000	nop
				;85	}
				;86	
				;87	void UART_Start(void)
				;88	{
				;89		if(_t3on)
				_UART_Start:
				_UART_Start:
01FC	3DDE	sz      T3ON
01FD	2A3A	jmp     _L24
				;90			return;
				;91	    if(uart_head!=uart_tail){
01FE	4710	mov     a, uart_head[0]
01FF	4094	mov     ra, a
0200	470F	mov     a, uart_tail[0]
0201	4097	mov     rd, a
0202	4714	mov     a, ra
0203	4217	sub     a, rd
0204	3D0A	sz      Z
0205	2A1C	jmp     _L26
				;92	        uart_out_buf = uart_buf[uart_tail];
0206	4717	mov     a, rd
0207	4095	mov     rb, a
0208	5F16	clr     rc
0209	3F85	sz      ACC.7
020A	5F96	set     rc
020B	0F80	mov     a, 80H
020C	4315	add     a, rb
020D	0083	mov     MP1, a
020E	0F04	mov     a, 4H
020F	5316	adc     a, rc
0210	0081	mov     MP0, a
0211	2019	call    L0019
0212	4092	mov     uart_out_buf[0], a
				;93	        uart_buf[uart_tail] = 0;
0213	0701	mov     a, MP0
0214	0084	mov     BP, a
0215	0F00	mov     a, 0H
0216	0082	mov     [02H], a
				;94	        uart_tail++;
0217	5497	inc     rd
				;95	        uart_tail = uart_tail & 0x7f; 
0218	7797	clr     rd.7
0219	4717	mov     a, rd
021A	408F	mov     uart_tail[0], a
021B	2A36	jmp     _L27
				;96	    }else if(uart_buf[uart_head]!=0){
				_L26:
021C	4714	mov     a, ra
021D	4095	mov     rb, a
021E	5F16	clr     rc
021F	3F85	sz      ACC.7
0220	5F96	set     rc
0221	0F80	mov     a, 80H
0222	4315	add     a, rb
0223	0083	mov     MP1, a
0224	0F04	mov     a, 4H
0225	5316	adc     a, rc
0226	0081	mov     MP0, a
0227	2019	call    L0019
0228	4095	mov     rb, a
0229	5095	sz      rb
022A	2A2C	jmp     _LI1
022B	2A3A	jmp     _L24
				;97	        uart_out_buf = uart_buf[uart_tail];
				_LI1:
022C	4715	mov     a, rb
022D	4092	mov     uart_out_buf[0], a
				;98	        uart_buf[uart_tail] = 0;
022E	0701	mov     a, MP0
022F	0084	mov     BP, a
0230	0F00	mov     a, 0H
0231	0082	mov     [02H], a
				;99	        uart_tail++;
0232	5494	inc     ra
				;100	        uart_tail = uart_tail & 0x7f; 
0233	7794	clr     ra.7
0234	4714	mov     a, ra
0235	408F	mov     uart_tail[0], a
				;101	    }else{
				;102	        return;
				;103	    }
				;104	    uart_step = 0;
				_L27:
0236	5F13	clr     uart_step[0]
				;105		uart_pin_buf = 1;
0237	0F01	mov     a, 1H
0238	4091	mov     uart_pin_buf[0], a
				;106	    _t3on = 1;
0239	31DE	set     T3ON
				_L24:
023A	0003	ret
				;107	}
				;108	
				;109	void UART_Stop(void)
				;110	{
				;111	    _t3on = 0;
01C1	35DE	clr     T3ON
01C2	29DC	jmp     _L1
				;112	}
				;113	
				;114	char UART_Put_Char(char ch)
				;115	{
				_UART_Put_Char:
				_UART_Put_Char:
023B	40A3	mov     ch[0], a
				;116	    if(uart_head==uart_tail){
023C	4710	mov     a, uart_head[0]
023D	4094	mov     ra, a
0249	4714	mov     a, ra
024A	420F	sub     a, uart_tail[0]
024B	390A	snz     Z
024C	2A51	jmp     L0251
				;117	        if(uart_buf[uart_head]==0){
023E	4714	mov     a, ra
023F	4095	mov     rb, a
0240	5F16	clr     rc
0241	3F85	sz      ACC.7
0242	5F96	set     rc
0243	0F80	mov     a, 80H
0244	4315	add     a, rb
0245	0083	mov     MP1, a
0246	0F04	mov     a, 4H
0247	5316	adc     a, rc
0248	0081	mov     MP0, a
024D	2019	call    L0019
024E	40A4	mov     data, a
024F	50A4	sz      data
0250	2A5C	jmp     L025C
				;118	            uart_buf[uart_head] = ch;
				;119	            uart_head++;
				;120	            uart_head = uart_head & 0x7f; 
				;121	        }
				;122	        else{
				;123	            return UART_Buffer_Full;
				L025C:
025C	0F01	mov     a, 1H
025D	4094	mov     ra, a
				;124	        }
				;125	    }else{
				;126	        uart_buf[uart_head] = ch;
				L0251:
0251	0701	mov     a, MP0
0252	0084	mov     BP, a
0253	4723	mov     a, ch[0]
0254	0082	mov     [02H], a
				;127	        uart_head++;
0255	5494	inc     ra
				;128	        uart_head = uart_head & 0x7f; 
0256	7794	clr     ra.7
0257	4714	mov     a, ra
0258	4090	mov     uart_head[0], a
				;129	    }
				;130	    return UART_Buffer_Add_Success;
0259	0F02	mov     a, 2H
025A	4094	mov     ra, a
025B	2A5E	jmp     L025E
				;131	}
				L025E:
025E	4714	mov     a, ra
025F	0003	ret
				;132	
				;133	#endif
				;file C:\Users\james\Google 雲端硬碟\自製版子\holtek\GitHub\HT_USB_Project\HT66FB550_USB_Common\HT66FB550_IO.c
				;1	#include "HT66FB550.h"
				;2	#include "HT66FB550_MCU.h"
				;3	#include "HT66FB550_IO.h"
				;4	#include "HT66FB550_typedef.h"
				;5	
				;6	//io direction buf
				;7	char port_A_config,port_B_config,port_C_config,port_D_config,port_E_config;
				;8	//io data buf
				;9	char port_A_data,port_B_data,port_C_data,port_D_data,port_E_data;
				;10	//io pull-high buf
				;11	char port_A_pull_high,port_B_pull_high,port_C_pull_high,port_D_pull_high,port_E_pull_high;
				;12	
				;13	void HT66FB550_IO_INIT(void)
				;14	{
				;15		HT66FB550_IO_DIR(HT66FB550_MCU_IO_PA,HT66FB550_MCU_IO_PINALL,HT66FB550_MCU_IO_OUTPUT);
				_HT66FB550_IO_INIT:
				_HT66FB550_IO_INIT:
0136	5F24	clr     data
0137	5FA3	set     ch
0138	0F00	mov     a, 0H
0139	204C	call    _HT66FB550_IO_DIR
				;16		HT66FB550_IO_DIR(HT66FB550_MCU_IO_PB,HT66FB550_MCU_IO_PINALL,HT66FB550_MCU_IO_OUTPUT);
013A	5F24	clr     data
013B	5FA3	set     ch
013C	0F01	mov     a, 1H
013D	204C	call    _HT66FB550_IO_DIR
				;17		HT66FB550_IO_DIR(HT66FB550_MCU_IO_PC,HT66FB550_MCU_IO_PINALL,HT66FB550_MCU_IO_OUTPUT);
013E	5F24	clr     data
013F	5FA3	set     ch
0140	0F02	mov     a, 2H
0141	204C	call    _HT66FB550_IO_DIR
				;18		HT66FB550_IO_DIR(HT66FB550_MCU_IO_PD,HT66FB550_MCU_IO_PINALL,HT66FB550_MCU_IO_OUTPUT);
0142	5F24	clr     data
0143	5FA3	set     ch
0144	0F03	mov     a, 3H
0145	204C	call    _HT66FB550_IO_DIR
				;19		HT66FB550_IO_DIR(HT66FB550_MCU_IO_PE,HT66FB550_MCU_IO_PINALL,HT66FB550_MCU_IO_OUTPUT);
0146	5F24	clr     data
0147	5FA3	set     ch
0148	0F04	mov     a, 4H
0149	204C	call    _HT66FB550_IO_DIR
				;20		HT66FB550_IO_Data(HT66FB550_MCU_IO_PA,HT66FB550_MCU_IO_PINALL,0x00);
014A	5F24	clr     data
014B	5FA3	set     ch
014C	0F00	mov     a, 0H
014D	20C1	call    _HT66FB550_IO_Data
				;21		HT66FB550_IO_Data(HT66FB550_MCU_IO_PB,HT66FB550_MCU_IO_PINALL,0x00);
014E	5F24	clr     data
014F	5FA3	set     ch
0150	0F01	mov     a, 1H
0151	20C1	call    _HT66FB550_IO_Data
				;22		HT66FB550_IO_Data(HT66FB550_MCU_IO_PC,HT66FB550_MCU_IO_PINALL,0x00);
0152	5F24	clr     data
0153	5FA3	set     ch
0154	0F02	mov     a, 2H
0155	20C1	call    _HT66FB550_IO_Data
				;23		HT66FB550_IO_Data(HT66FB550_MCU_IO_PD,HT66FB550_MCU_IO_PINALL,0x00);
0156	5F24	clr     data
0157	5FA3	set     ch
0158	0F03	mov     a, 3H
0159	20C1	call    _HT66FB550_IO_Data
				;24		HT66FB550_IO_Data(HT66FB550_MCU_IO_PE,HT66FB550_MCU_IO_PINALL,0x00);
015A	5F24	clr     data
015B	5FA3	set     ch
015C	0F04	mov     a, 4H
015D	20C1	call    _HT66FB550_IO_Data
				;25	    //set ADC pin to IO pin here
				;26	    _acer0 = 0;
015E	1F33	clr     ACER0
				;27	    _acer1 = 0;
015F	1F34	clr     ACER1
0160	0003	ret
				;28	    
				;29	}
				;30	
				;31	void HT66FB550_IO_DIR(char port, char pin, char direction)
				;32	{
				_HT66FB550_IO_DIR:
				_HT66FB550_IO_DIR:
				@dummy .SECTION 'CODE'
004C	4094	mov     ra, a
				;33		char filter=0x01;
				;34		filter = filter << pin;
004D	0F01	mov     a, 1H
004E	4095	mov     rb, a
004F	5F16	clr     rc
0050	5423	inca    pin[0]
0051	2855	jmp     L0055
				L0052:
0052	340A	clr     C
0053	5A95	rlc     rb
0054	5A96	rlc     rc
				L0055:
0055	1785	sdz     ACC
0056	2852	jmp     L0052
0057	4715	mov     a, rb
0058	40A6	mov     filter[0], a
				;35		switch(port)
0059	4714	mov     a, ra
005A	0A00	sub     a, 0H
005B	3D0A	sz      Z
005C	286C	jmp     L006C
005D	0A01	sub     a, 1H
005E	3D0A	sz      Z
005F	287D	jmp     L007D
0060	4714	mov     a, ra
0061	0A02	sub     a, 2H
0062	3D0A	sz      Z
0063	288E	jmp     L008E
0064	0A01	sub     a, 1H
0065	3D0A	sz      Z
0066	289F	jmp     L009F
0067	4714	mov     a, ra
0068	0A04	sub     a, 4H
0069	390A	snz     Z
006A	28C0	jmp     L00C0
006B	28B0	jmp     L00B0
				;36		{
				;37			case HT66FB550_MCU_IO_PA:
				;38				switch(pin)
				;39				{
				;40					case HT66FB550_MCU_IO_PINALL:
				;41						port_A_config = direction;
				;42						break;
				;43					default:
				;44						port_A_config = port_A_config & (!filter);
				L006C:
006C	0F01	mov     a, 1H
006D	4094	mov     ra, a
006E	50A6	sz      filter[0]
006F	2871	jmp     L0071
0070	2872	jmp     L0072
				L0071:
0071	5F14	clr     ra
				L0072:
0072	470E	mov     a, port_A_config[0]
0073	4694	andm    a, ra
				;45						port_A_config = port_A_config | (filter & direction);
0074	4724	mov     a, direction[0]
0075	4695	andm    a, rb
0076	4714	mov     a, ra
0077	4595	orm     a, rb
0078	4715	mov     a, rb
0079	408E	mov     port_A_config[0], a
				;46						break;
				;47				}
				;48				_pac = port_A_config;
007A	4715	mov     a, rb
007B	009B	mov     PAC, a
				;49				break;
007C	28C0	jmp     L00C0
				;50			case HT66FB550_MCU_IO_PB:
				;51				switch(pin)
				;52				{
				;53					case HT66FB550_MCU_IO_PINALL:
				;54						port_B_config = direction;
				;55						break;
				;56					default:
				;57						port_B_config = port_B_config & (!filter);
				L007D:
007D	0F01	mov     a, 1H
007E	4094	mov     ra, a
007F	50A6	sz      filter[0]
0080	2882	jmp     L0082
0081	2883	jmp     L0083
				L0082:
0082	5F14	clr     ra
				L0083:
0083	470D	mov     a, port_B_config[0]
0084	4694	andm    a, ra
				;58						port_B_config = port_B_config | (filter & direction);
0085	4724	mov     a, direction[0]
0086	4695	andm    a, rb
0087	4714	mov     a, ra
0088	4595	orm     a, rb
0089	4715	mov     a, rb
008A	408D	mov     port_B_config[0], a
				;59						break;
				;60				}
				;61				_pbc = port_B_config;
008B	4715	mov     a, rb
008C	00A3	mov     PBC, a
				;62				break;
008D	28C0	jmp     L00C0
				;63			case HT66FB550_MCU_IO_PC:
				;64				switch(pin)
				;65				{
				;66					case HT66FB550_MCU_IO_PINALL:
				;67						port_C_config = direction;
				;68						break;
				;69					default:
				;70						port_C_config = port_C_config & (!filter);
				L008E:
008E	0F01	mov     a, 1H
008F	4094	mov     ra, a
0090	50A6	sz      filter[0]
0091	2893	jmp     L0093
0092	2894	jmp     L0094
				L0093:
0093	5F14	clr     ra
				L0094:
0094	470C	mov     a, port_C_config[0]
0095	4694	andm    a, ra
				;71						port_C_config = port_C_config | (filter & direction);
0096	4724	mov     a, direction[0]
0097	4695	andm    a, rb
0098	4714	mov     a, ra
0099	4595	orm     a, rb
009A	4715	mov     a, rb
009B	408C	mov     port_C_config[0], a
				;72						break;
				;73				}
				;74				_pcc = port_C_config;
009C	4715	mov     a, rb
009D	00A5	mov     PCC, a
				;75				break;
009E	28C0	jmp     L00C0
				;76			case HT66FB550_MCU_IO_PD:
				;77				switch(pin)
				;78				{
				;79					case HT66FB550_MCU_IO_PINALL:
				;80						port_D_config = direction;
				;81						break;
				;82					default:
				;83						port_D_config = port_D_config & (!filter);
				L009F:
009F	0F01	mov     a, 1H
00A0	4094	mov     ra, a
00A1	50A6	sz      filter[0]
00A2	28A4	jmp     L00A4
00A3	28A5	jmp     L00A5
				L00A4:
00A4	5F14	clr     ra
				L00A5:
00A5	470B	mov     a, port_D_config[0]
00A6	4694	andm    a, ra
				;84						port_D_config = port_D_config | (filter & direction);
00A7	4724	mov     a, direction[0]
00A8	4695	andm    a, rb
00A9	4714	mov     a, ra
00AA	4595	orm     a, rb
00AB	4715	mov     a, rb
00AC	408B	mov     port_D_config[0], a
				;85						break;
				;86				}
				;87				_pdc = port_D_config;
00AD	4715	mov     a, rb
00AE	00A7	mov     PDC, a
				;88				break;
00AF	28C0	jmp     L00C0
				;89			case HT66FB550_MCU_IO_PE:
				;90				switch(pin)
				;91				{
				;92					case HT66FB550_MCU_IO_PINALL:
				;93						port_E_config = direction;
				;94						break;
				;95					default:
				;96						port_E_config = port_E_config & (!filter);
				L00B0:
00B0	0F01	mov     a, 1H
00B1	4094	mov     ra, a
00B2	50A6	sz      filter[0]
00B3	28B5	jmp     L00B5
00B4	28B6	jmp     L00B6
				L00B5:
00B5	5F14	clr     ra
				L00B6:
00B6	470A	mov     a, port_E_config[0]
00B7	4694	andm    a, ra
				;97						port_E_config = port_E_config | (filter & direction);
00B8	4724	mov     a, direction[0]
00B9	4695	andm    a, rb
00BA	4714	mov     a, ra
00BB	4595	orm     a, rb
00BC	4715	mov     a, rb
00BD	408A	mov     port_E_config[0], a
				;98						break;
				;99				}
				;100				_pec = port_E_config;
00BE	4715	mov     a, rb
00BF	00A9	mov     PEC, a
				L00C0:
00C0	0003	ret
				;101				break;
				;102		}	
				;103	}
				;104	
				;105	void HT66FB550_IO_Data(char port, char pin, char data)
				;106	{
				_HT66FB550_IO_Data:
				_HT66FB550_IO_Data:
00C1	4094	mov     ra, a
				;107		char filter=0x01;
				;108		filter = filter << pin;
00C2	0F01	mov     a, 1H
00C3	4095	mov     rb, a
00C4	5F16	clr     rc
00C5	5423	inca    pin[0]
00C6	28CA	jmp     L00CA
				L00C7:
00C7	340A	clr     C
00C8	5A95	rlc     rb
00C9	5A96	rlc     rc
				L00CA:
00CA	1785	sdz     ACC
00CB	28C7	jmp     L00C7
00CC	4715	mov     a, rb
00CD	40A6	mov     filter[0], a
				;109		switch(port)
00CE	4714	mov     a, ra
00CF	0A00	sub     a, 0H
00D0	3D0A	sz      Z
00D1	28E1	jmp     L00E1
00D2	0A01	sub     a, 1H
00D3	3D0A	sz      Z
00D4	28F2	jmp     L00F2
00D5	4714	mov     a, ra
00D6	0A02	sub     a, 2H
00D7	3D0A	sz      Z
00D8	2903	jmp     L0103
00D9	0A01	sub     a, 1H
00DA	3D0A	sz      Z
00DB	2914	jmp     L0114
00DC	4714	mov     a, ra
00DD	0A04	sub     a, 4H
00DE	390A	snz     Z
00DF	2935	jmp     L0135
00E0	2925	jmp     L0125
				;110		{
				;111			case HT66FB550_MCU_IO_PA:
				;112				switch(pin)
				;113				{
				;114					case HT66FB550_MCU_IO_PINALL:
				;115						port_A_data = data;
				;116						break;
				;117					default:
				;118						port_A_data = port_A_data & (!filter);
				L00E1:
00E1	0F01	mov     a, 1H
00E2	4094	mov     ra, a
00E3	50A6	sz      filter[0]
00E4	28E6	jmp     L00E6
00E5	28E7	jmp     L00E7
				L00E6:
00E6	5F14	clr     ra
				L00E7:
00E7	4709	mov     a, port_A_data[0]
00E8	4694	andm    a, ra
				;119						port_A_data = port_A_data | (filter & data);
00E9	4724	mov     a, data[0]
00EA	4695	andm    a, rb
00EB	4714	mov     a, ra
00EC	4595	orm     a, rb
00ED	4715	mov     a, rb
00EE	4089	mov     port_A_data[0], a
				;120						break;
				;121				}
				;122				_pa = port_A_data;
00EF	4715	mov     a, rb
00F0	009A	mov     PA, a
				;123				break;
00F1	2935	jmp     L0135
				;124			case HT66FB550_MCU_IO_PB:
				;125				switch(pin)
				;126				{
				;127					case HT66FB550_MCU_IO_PINALL:
				;128						port_B_data = data;
				;129						break;
				;130					default:
				;131						port_B_data = port_B_data & (!filter);
				L00F2:
00F2	0F01	mov     a, 1H
00F3	4094	mov     ra, a
00F4	50A6	sz      filter[0]
00F5	28F7	jmp     L00F7
00F6	28F8	jmp     L00F8
				L00F7:
00F7	5F14	clr     ra
				L00F8:
00F8	4708	mov     a, port_B_data[0]
00F9	4694	andm    a, ra
				;132						port_B_data = port_B_data | (filter & data);
00FA	4724	mov     a, data[0]
00FB	4695	andm    a, rb
00FC	4714	mov     a, ra
00FD	4595	orm     a, rb
00FE	4715	mov     a, rb
00FF	4088	mov     port_B_data[0], a
				;133						break;
				;134				}
				;135				_pb = port_B_data;
0100	4715	mov     a, rb
0101	00A2	mov     PB, a
				;136				break;
0102	2935	jmp     L0135
				;137			case HT66FB550_MCU_IO_PC:
				;138				switch(pin)
				;139				{
				;140					case HT66FB550_MCU_IO_PINALL:
				;141						port_C_data = data;
				;142						break;
				;143					default:
				;144						port_C_data = port_C_data & (!filter);
				L0103:
0103	0F01	mov     a, 1H
0104	4094	mov     ra, a
0105	50A6	sz      filter[0]
0106	2908	jmp     L0108
0107	2909	jmp     L0109
				L0108:
0108	5F14	clr     ra
				L0109:
0109	4707	mov     a, port_C_data[0]
010A	4694	andm    a, ra
				;145						port_C_data = port_C_data | (filter & data);
010B	4724	mov     a, data[0]
010C	4695	andm    a, rb
010D	4714	mov     a, ra
010E	4595	orm     a, rb
010F	4715	mov     a, rb
0110	4087	mov     port_C_data[0], a
				;146						break;
				;147				}
				;148				_pc = port_C_data;
0111	4715	mov     a, rb
0112	00A4	mov     PC, a
				;149				break;
0113	2935	jmp     L0135
				;150			case HT66FB550_MCU_IO_PD:
				;151				switch(pin)
				;152				{
				;153					case HT66FB550_MCU_IO_PINALL:
				;154						port_D_data = data;
				;155						break;
				;156					default:
				;157						port_D_data = port_D_data & (!filter);
				L0114:
0114	0F01	mov     a, 1H
0115	4094	mov     ra, a
0116	50A6	sz      filter[0]
0117	2919	jmp     L0119
0118	291A	jmp     L011A
				L0119:
0119	5F14	clr     ra
				L011A:
011A	4706	mov     a, port_D_data[0]
011B	4694	andm    a, ra
				;158						port_D_data = port_D_data | (filter & data);
011C	4724	mov     a, data[0]
011D	4695	andm    a, rb
011E	4714	mov     a, ra
011F	4595	orm     a, rb
0120	4715	mov     a, rb
0121	4086	mov     port_D_data[0], a
				;159						break;
				;160				}
				;161				_pd = port_D_data;
0122	4715	mov     a, rb
0123	00A6	mov     PD, a
				;162				break;
0124	2935	jmp     L0135
				;163			case HT66FB550_MCU_IO_PE:
				;164				switch(pin)
				;165				{
				;166					case HT66FB550_MCU_IO_PINALL:
				;167						port_E_data = data;
				;168						break;
				;169					default:
				;170						port_E_data = port_E_data & (!filter);
				L0125:
0125	0F01	mov     a, 1H
0126	4094	mov     ra, a
0127	50A6	sz      filter[0]
0128	292A	jmp     L012A
0129	292B	jmp     L012B
				L012A:
012A	5F14	clr     ra
				L012B:
012B	4705	mov     a, port_E_data[0]
012C	4694	andm    a, ra
				;171						port_E_data = port_E_data | (filter & data);
012D	4724	mov     a, data[0]
012E	4695	andm    a, rb
012F	4714	mov     a, ra
0130	4595	orm     a, rb
0131	4715	mov     a, rb
0132	4085	mov     port_E_data[0], a
				;172						break;
				;173				}
				;174				_pe = port_E_data;
0133	4715	mov     a, rb
0134	00A8	mov     PE, a
				L0135:
0135	0003	ret
				;175				break;
				;176		}		
				;177	}
				;178	
				;179	void HT66FB550_IO_Pull_High(char port, char pin, char data)
				;180	{
				;181		char filter=0x01;
				;182		filter = filter << pin;
				;183		switch(port)
				;184		{
				;185			case HT66FB550_MCU_IO_PA:
				;186				switch(pin==HT66FB550_MCU_IO_PINALL)
				;187				{
				;188					case HT66FB550_MCU_IO_PINALL:
				;189						port_A_pull_high = data;
				;190						break;
				;191					default:
				;192						port_A_pull_high = port_A_pull_high & (!filter);
				;193						port_A_pull_high = port_A_pull_high | (filter & data);
				;194						break;
				;195				}
				;196				_pa = port_A_pull_high;
				;197				break;
				;198			case HT66FB550_MCU_IO_PB:
				;199				switch(pin==HT66FB550_MCU_IO_PINALL)
				;200				{
				;201					case HT66FB550_MCU_IO_PINALL:
				;202						port_B_pull_high = data;
				;203						break;
				;204					default:
				;205						port_B_pull_high = port_B_pull_high & (!filter);
				;206						port_B_pull_high = port_B_pull_high | (filter & data);
				;207						break;
				;208				}
				;209				_pb = port_B_pull_high;
				;210				break;
				;211			case HT66FB550_MCU_IO_PC:
				;212				switch(pin==HT66FB550_MCU_IO_PINALL)
				;213				{
				;214					case HT66FB550_MCU_IO_PINALL:
				;215						port_C_pull_high = data;
				;216						break;
				;217					default:
				;218						port_C_pull_high = port_C_pull_high & (!filter);
				;219						port_C_pull_high = port_C_pull_high | (filter & data);
				;220						break;
				;221				}
				;222				_pc = port_C_pull_high;
				;223				break;
				;224			case HT66FB550_MCU_IO_PD:
				;225				switch(pin==HT66FB550_MCU_IO_PINALL)
				;226				{
				;227					case HT66FB550_MCU_IO_PINALL:
				;228						port_D_pull_high = data;
				;229						break;
				;230					default:
				;231						port_D_pull_high = port_D_pull_high & (!filter);
				;232						port_D_pull_high = port_D_pull_high | (filter & data);
				;233						break;
				;234				}
				;235				_pd = port_D_pull_high;
				;236				break;
				;237			case HT66FB550_MCU_IO_PE:
				;238				switch(pin==HT66FB550_MCU_IO_PINALL)
				;239				{
				;240					case HT66FB550_MCU_IO_PINALL:
				;241						port_E_pull_high = data;
				;242						break;
				;243					default:
				;244						port_E_pull_high = port_E_pull_high & (!filter);
				;245						port_E_pull_high = port_E_pull_high | (filter & data);
				;246						break;
				;247				}
				;248				_pe = port_E_pull_high;
				;249				break;
				;250		}			
				;251	}
				;252	
				;253	void HT66FB550_IO_High_Current(char port, char data)
				;254	{
				;255		switch(port)
				;256		{
				;257			case HT66FB550_MCU_IO_PA:
				;258				switch(data)
				;259				{
				;260					case HT66FB550_MCU_IO_DATA_SET:
				;261						_paoi = 0xff;
				;262						break;
				;263					case HT66FB550_MCU_IO_DATA_CLEAR:
				;264					default:
				;265						_paoi = 0x00;
				;266						break;
				;267				}
				;268				break;
				;269			case HT66FB550_MCU_IO_PB:
				;270				switch(data)
				;271				{
				;272					case HT66FB550_MCU_IO_DATA_SET:
				;273						_pbhi = 1;
				;274						_pbli = 1;
				;275						break;
				;276					case HT66FB550_MCU_IO_DATA_CLEAR:
				;277					default:
				;278						_pbhi = 0;
				;279						_pbli = 0;
				;280						break;
				;281				}
				;282			case HT66FB550_MCU_IO_PC:
				;283				switch(data)
				;284				{
				;285					case HT66FB550_MCU_IO_DATA_SET:
				;286						_pchi = 1;
				;287						_pcli = 1;
				;288						break;
				;289					case HT66FB550_MCU_IO_DATA_CLEAR:
				;290					default:
				;291						_pchi = 0;
				;292						_pcli = 0;
				;293						break;
				;294				}
				;295			case HT66FB550_MCU_IO_PD:
				;296				switch(data)
				;297				{
				;298					case HT66FB550_MCU_IO_DATA_SET:
				;299						_pdhi = 1;
				;300						_pdli = 1;
				;301						break;
				;302					case HT66FB550_MCU_IO_DATA_CLEAR:
				;303					default:
				;304						_pdhi = 0;
				;305						_pdli = 0;
				;306						break;
				;307				}
				;308			case HT66FB550_MCU_IO_PE:
				;309				switch(data)
				;310				{
				;311					case HT66FB550_MCU_IO_DATA_SET:
				;312						_pehi = 1;
				;313						_peli = 1;
				;314						break;
				;315					case HT66FB550_MCU_IO_DATA_CLEAR:
				;316					default:
				;317						_pehi = 0;
				;318						_peli = 0;
				;319						break;
				;320				}
				;321		}			
				;322	}
				;323	
				;324	void HT66FB550_IO_Slew_Rate(void)
				;325	{
				;326	    
				;327	}
				;328	void HT66FB550_IO_Port_A_Output_Power_Control(char pin, char power_source)
				;329	{
				;330		
				;331	}
				data .SECTION 'DATA'
				__smod DB DUP (?) ; __smod
				__wdtc DB DUP (?) ; __wdtc
				__intc0 DB DUP (?) ; __intc0
				__intc2 DB DUP (?) ; __intc2
				__mfi1 DB DUP (?) ; __mfi1
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__paoi DB DUP (?) ; __paoi
				__pxoi DB DUP (?) ; __pxoi
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pd DB DUP (?) ; __pd
				__pdc DB DUP (?) ; __pdc
				__pe DB DUP (?) ; __pe
				__pec DB DUP (?) ; __pec
				__acer0 DB DUP (?) ; __acer0
				__acer1 DB DUP (?) ; __acer1
				__tm3c0 DB DUP (?) ; __tm3c0
				__tm3c1 DB DUP (?) ; __tm3c1
				__tm3al DB DUP (?) ; __tm3al
				__tm3ah DB DUP (?) ; __tm3ah
				__usc DB DUP (?) ; __usc
				__ucc DB DUP (?) ; __ucc
				port_E_pull_high DB DUP (?) ; port_E_pull_high
				port_D_pull_high DB DUP (?) ; port_D_pull_high
				port_C_pull_high DB DUP (?) ; port_C_pull_high
				port_B_pull_high DB DUP (?) ; port_B_pull_high
				port_A_pull_high DB DUP (?) ; port_A_pull_high
				port_E_data DB DUP (?) ; port_E_data
				port_D_data DB DUP (?) ; port_D_data
				port_C_data DB DUP (?) ; port_C_data
				port_B_data DB DUP (?) ; port_B_data
				port_A_data DB DUP (?) ; port_A_data
				port_E_config DB DUP (?) ; port_E_config
				port_D_config DB DUP (?) ; port_D_config
				port_C_config DB DUP (?) ; port_C_config
				port_B_config DB DUP (?) ; port_B_config
				port_A_config DB DUP (?) ; port_A_config
				uart_tail DB DUP (?) ; uart_tail
				uart_head DB DUP (?) ; uart_head
				uart_pin_buf DB DUP (?) ; uart_pin_buf
				uart_out_buf DB DUP (?) ; uart_out_buf
				uart_step DB DUP (?) ; uart_step
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				ra24 DB DUP (?)
				rb24 DB DUP (?)
				rd24 DB DUP (?)
				rc24 DB DUP (?)
				r124 DB DUP (?)
				r224 DB DUP (?)
				r324 DB DUP (?)
				r424 DB DUP (?)
				r524 DB DUP (?)
				r624 DB DUP (?)
				r724 DB DUP (?)
				ch DB DUP (?) ; ch
				data DB DUP (?) ; data
				port DB DUP (?) ; port
				filter DB DUP (?) ; filter
				a DB 2 DUP (?) ; a
				uart_buf DB DUP (?) ; uart_buf
